#!/usr/bin/env bash

# Script: crack
# Version 1.0
# Date: 15/03/2017
# Author: mnemonic AKA semeion
# Description: Automate the handshake cracking process
# dependencies: john (with jumbo3 rules), aircrack-ng, pyrit, scapy, less

shopt -s extglob

# Check dependencies
dependencies=(john aircrack-ng pyrit scapy less xterm grep egrep sha1sum wc cut tr awk sudo)
for c in "${dependencies[@]}"; do
    if ! type "$c" &>/dev/null; then
        echo "${c}: command not found"
        exit 1
    fi
done

[[ ! -d "$HOME/.john" ]] && mkdir -p "$HOME/.john" &>/dev/null

if [ -f "/etc/john/john.conf.custom" ]; then
    if [ ! -f "$HOME/.john/john.conf.backup" ]; then
        if cp "$HOME/.john/john.conf" "$HOME/.john/john.conf.backup" &>/dev/null; then
            echo "$HOME/.john/john.conf saved to $HOME/.john/john.conf.backup"
        fi
        cp "/etc/john/john.conf.custom" "$HOME/.john/john.conf" &>/dev/null
    fi
else
    echo "/etc/john/john.conf.custom not found"
    exit 1
fi

[[ "$PATH" =~ "$PWD" ]] || export PATH=$PATH:$PWD
configdir="${HOME}/.config/handshake-cracker"
[[ ! -d "$configdir" ]] && mkdir -p "$configdir" &>/dev/null
configfile="$configdir/scripts.conf"

if [ ! -f "$configfile" ]; then
echo "\
handshakes_dir=${configdir}/handshakes               # Handshakes directory - used by crack
sessions_dir=${configdir}/crack-sessions             # Script work directory - used by crack
wordlist_dir=${configdir}/wordlists                  # Directory to save wordlists - used by wordlist
wordlist=${configdir}/wordlists/wordlist.dic         # Password file - used by crack/wordlist
maxlength=50                                         # Max length of words to be used from wordlist - used by crack
john_incr=Digits8                                    # John incremental mode to be used - used by crack
john_rule=My                                         # John rule to be used - used by crack
deauth_time=3                                        # Tries to Deauth Clients Quickly - used by handshake" >"$configfile"
fi

# check if the file contains something we don't want
configfile_secured='/tmp/handshake-cracker-secured-scripts.conf'
if egrep -q -v '^#|^[^ ]*=[^;]*' "$configfile"; then
	echo "Config file is unclean, cleaning it..." >&2
	# filter the original to a new file
	egrep '^#|^[^ ]*=[^;&]*'  "$configfile" > "$configfile_secured"
	configfile="$configfile_secured"
fi
# now source it, either the original or the filtered variant
source "$configfile"

shopt -s nullglob
handshake_files=($handshakes_dir/*)
shopt -u nullglob
cpus=$(grep -c ^processor /proc/cpuinfo)
tempdir="/tmp"

white="\033[1;37m"
grey="\033[0;37m"
red="\033[1;31m"
green="\033[1;32m"
yellow="\033[1;33m"
blue="\033[1;34m"
cyan="\033[0;36m"
cafe="\033[0;33m"
fiuscha="\033[0;35m"
transparent="\e[0m"
VENTSCAN="-geometry 95x56-0+0"
VENTHAND="-geometry 95x20-0+0"
VENTDEAU="-geometry 80x20-0-30"
WINDOWCRACK="-geometry 80x21-0+0"

if [ ! -d $sessions_dir ]; then mkdir -p $sessions_dir &>/dev/null; fi # Create script work directory

# Usage: if confirm "Are you sure? "; then ...
confirm() { local ans IFS=; while read -rp "$1" -n1 ans; do printf '\n'; case $ans in [Yy]) return 0;; ''|[Nn]) return 1;; esac; done; };

function top {
    echo -en "\e[3J"
    echo
    echo -e "$green  ##########################################################"
    echo -e "$green  #                                                        #"
    echo -e "$green  #            PASSWORD CRACKER 1.0 by mnemonic            #"
    echo -e "$green  #                                                        #"
    echo -e "$green  ########################################################## ${transparent}"
    echo
}

function load_handshakes {
    for ((i=0; i<${#handshake_files[@]}; i++)); do
        handshake_filename="${handshake_files[$i]}"
        echo -n "Checking ${handshake_files[$i]} "
        pyrit_output=$(pyrit -r "${handshake_files[$i]}" analyze 2>&1)
        bssid[$i]=$(echo "${pyrit_output}" | grep "^#" | cut -d " " -f3 | tr '[:lower:]' '[:upper:]')
        essid[$i]=$(echo "${pyrit_output}" | grep "^#" | cut -d "(" -f2 | cut -d "'" -f2)
        echo "${pyrit_output}" | grep -v "AccessPoint" | grep -q 'good[*]\?,' 2>&1
        exitcode[$i]="$?"
        if (( exitcode[$i]==0 )); then
            echo " ( OK )"
        else
            echo " ( BAD )"
        fi
        #~ echo -e "${color}${bssid[$i]}\t${essid[$i]}\t${status[$i]}${transparent}"
    done
}

function select_handshake {
    local status order process cracked cores
    while [ 1 ]; do
        clear
        top
        echo "                                  WORDS   CRACK       CPU"
        echo "  Nº          BSSID       STATUS  LENGTH  PROCESS     CORES   CRAKED    ESSID"
        echo
        for ((i=0; i<${#handshake_files[@]}; i++)); do
            if (( exitcode[$i]==0 )); then
                status="${green}GOOD${transparent}"
            else
                status="${red}BAD${transparent}"
            fi
            if [ -f "${sessions_dir}/${bssid[$i]}.session" ]; then
                order="$(<${sessions_dir}/${bssid[$i]}.session)"
                if [[ $order == "INC" ]]; then
                    order="${yellow}$(<${sessions_dir}/${bssid[$i]}.session)${transparent}"
                else
                    order="${yellow}$(<${sessions_dir}/${bssid[$i]}.session)${transparent}/${yellow}${maxlength}${transparent}"
                fi
            else
                order="-"
            fi
            if [ -f "${sessions_dir}/${bssid[$i]}.cracked" ]; then
                cracked="${green}YES${transparent}"
            else
                cracked="${red}NO${transparent}"
            fi
            if is_running "${bssid[$i]}"; then
                process="${green}RUNNING${transparent}"
                cores=$(ps -ef | grep -Ev 'sh -c|grep|xterm' | grep "[0-9][0-9]:[0-9][0-9]:[0-9][0-9] aircrack-ng -p .*${bssid[$i]}.cap$" | awk '{ print $10 }')
                cores="${green}${cores}${transparent}"
            else
                process="${red}STOPPED${transparent}"
                cores="0"
            fi
            echo -e "  [${yellow}$((i+1))${transparent}]\t${cyan}${bssid[$i]}  ${status}\t   ${order}\t  ${process}\t${cores}\t${cracked}\t${essid[$i]}\t${transparent}"
        done
        echo
        echo -ne "  [${yellow}C${transparent}]apture handshake  [${yellow}U${transparent}]pdate wordlist  [${yellow}S${transparent}]tatistics  [${yellow}Q${transparent}]uit): "
        read choice

        case "$choice" in
            +([0-9]))
                if (( choice > 0 && choice <= ${#handshake_files[@]} )); then
                    choice=$(($choice-1))
                    if [ -f "${sessions_dir}/${bssid[$choice]}.rec" ]; then
                        status="$(john --status=${sessions_dir}/${bssid[$choice]} 2>&1)"
                        echo -e "\n  $status\n"
                    fi
                    if is_running "${bssid[$choice]}"; then
                        if confirm "  Is already running. Do you want to stop? (y/N): "; then
                            stop "${bssid[$choice]}"
                            sleep 1
                        fi
                    else
                        if [ -f "${sessions_dir}/${bssid[$choice]}.cracked" ]; then
                            status="$(< ${sessions_dir}/${bssid[$choice]}.cracked)"
                            echo -ne "  The handshake was cracked in last process. Password found: '${status}' "
                            read -n1 choice
                        else
                            if [ -f "${wordlist}" ]; then
                                cores=0
                                while (( cores < 1 || cores > cpus )); do
                                    echo -ne "${yellow}  Number of CPU cores to use (${transparent}${yellow}1${transparent}-${yellow}${cpus}${transparent}): "
                                    read -n 1 cores
                                    echo
                                done
                                crack_handshake "${bssid[$choice]}" "${cores}" &
                                sleep 1
                            else
                                echo
                                echo "  Update your wordlist first! The cracking process need a wordlist!"
                                echo "  ${wordlist} does not exist!"
                                echo "  If you want to use a specific wordlist, set this in:"
                                echo "  ${configfile}"
                                echo
                                echo -ne "  Press a key to return "
                                read -n1 choice
                            fi
                        fi
                    fi
                else
                    select_handshake
                fi
                ;;
            c|C)
                echo -n "  "
                sudo handshake
                shopt -s nullglob
                handshake_files=($handshakes_dir/*)
                shopt -u nullglob
                load_handshakes
                ;;
            u|U)
                wordlist --get
                wordlist --makediff
                if confirm "  Want to see the new words? (y/N): "; then
                    less "${wordlist}.diff"
                fi
                if confirm "  Want to add to the wordlist? (y/N): "; then
                    wordlist --add
                fi
                echo "  Press a key to return"
                read -n1 choice
                ;;
            s|S)
                echo "  STATISTICS OF PROCESS"
                statistics
                echo "  Press a key to return"
                read -n1 choice
                ;;
            q|Q)
                exit
                ;;
            *)
                select_handshake
                ;;
        esac
    done
}

function is_running {
    local bssid="$1"
    local john_pid=$(ps -ef | grep -Ev 'sh -c|grep|xterm' | grep "[0-9][0-9]:[0-9][0-9]:[0-9][0-9] john --.*${bssid}" | awk '{ print $2 }')
    if [ -z "${john_pid}" ]; then
        return 1
    else
        return 0
    fi
}

function stop {
    local bssid="$1"
    local john_pid=$(ps -ef | grep -Ev 'sh -c|grep|xterm' | grep "[0-9][0-9]:[0-9][0-9]:[0-9][0-9] john --.*${bssid}" | awk '{ print $2 }')
    if [ ! -z "${john_pid}" ]; then
        rm -f "${sessions_dir}/${bssid}.run"
        kill -INT "${john_pid}"
    fi
}

# Notes about this function:
#  1) RESTARTING THE TEST MANUALY (not recomended):
#     Deleting the *.rec file will bypass current test, going to next session (words length),
#     words in current session will be considered TESTED by the script (added in *.tested).
#     Words in *.tested will be ignored in future tests.
#     So, if you delete *.rec should consider delete *session and *.tested too. Except when performing
#     initial numeric incremental test (INC), in this case, deleting *.rec will just only bypass INC
#     test (INC test don´t add words in *.tested)
#  -  So, to restart a session from begin, delete *.session *.rec *.tested *.dic[0-99]
#  -  To restart the current session only, decrease the value inside *.session file, delete *.rec *.dic[0-99]
#  2) The passwords will be saved in *.cracked files
#  3) Each time the user update his wordlist, the sessions will be automatically restarted from 1, but no worries,
#     all tested words will be preserved and the cracking process will use not tested words only.
#     If necessary adjust 'maxlength' var to up after update the dictionary to use more words in new round.
function crack_handshake {
    local bssid="$1"
    local cores="$2"
    local session dic
    # Verify BSSID consistence, number of CPU cores, and if the process already running
    if [[ ! "$bssid" =~ ^([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}$ ]] || (( cores < 1 || cores > cpus )) || is_running "${bssid}"; then
        exit 1
    fi
    local biggest=$(wc -L "${wordlist}" | cut -d' ' -f1) # biggest word in wordlist
    if (( maxlength > biggest )); then
        maxlength="${biggest}"
    fi
    >"${sessions_dir}/${bssid}.run"
    while [ ! -f "${sessions_dir}/${bssid}.cracked" ] && [ -f "${sessions_dir}/${bssid}.run" ]; do
        #~ xterm_pid=$(wmctrl -lp | grep "Cracking ${bssid}" | awk '{ print $3 }')
        if ! is_running "${bssid}"; then
            # Previous crack session exist?
            if [ -f "${sessions_dir}/${bssid}.session" ]; then
                # Yes, restoring previous crack session
                session=$(<"${sessions_dir}/${bssid}.session")
                # Previous john *.rec exist?
                if [ -f "${sessions_dir}/${bssid}.rec" ]; then
                    # Resume previous john *.rec
                    xterm -title "Cracking ${bssid}" $WINDOWCRACK -bg "#000000" -fg "#FFFFFF" -e sh -c "john --restore=${sessions_dir}/${bssid} | aircrack-ng -p ${cores} -w - -b ${bssid} -l ${sessions_dir}/${bssid}.cracked ${handshakes_dir}/${bssid}.cap"
                else
                    # Add tested words to *.tested file, Create new dictionary with next word length, Step to next crack session
                    if [ -f "${sessions_dir}/${bssid}.dic${session}" ]; then
                        cat "${sessions_dir}/${bssid}.dic${session}" >>"${sessions_dir}/${bssid}.tested" # Add tested passwords to *.tested file
                        rm -rf "${sessions_dir}/${bssid}.dic${session}"
                    fi
                    if [[ $session == "INC" ]]; then    # Previous crack session was incremental?
                        # Start cracking process using dictionary with 1 length words
                        session="1"
                    else
                        # Start cracking process using dictionary with next length words
                        session=$(($session+1))
                    fi
                    # Get wordlist sha1sum
                    if [ ! -f "${sessions_dir}/${bssid}.sha1sum" ]; then
                        sha1sum "${wordlist}" >"${sessions_dir}/${bssid}.sha1sum"
                    fi
                    # Check if wordlist was modified and restart the session if necessary
                    saved_hash=$(<"${sessions_dir}/${bssid}.sha1sum")
                    dict_hash=$(sha1sum "${wordlist}")
                    if [ "$saved_hash" != "$dict_hash" ]; then
                        sha1sum "${wordlist}" >"${sessions_dir}/${bssid}.sha1sum"
						session="1"
                    fi
                    if (( session <= maxlength )); then
                        [ ! -f "${sessions_dir}/${bssid}.tested" ] && >"${sessions_dir}/${bssid}.tested" # if *.tested don´t exist, create
                        grep -E "^.{$session,$session}$" "${wordlist}" | grep -vxF -f "${sessions_dir}/${bssid}.tested" >"${sessions_dir}/${bssid}.dic${session}" # Create a dictionary excluding .tested words
                        echo "$session" >"${sessions_dir}/${bssid}.session"
                        sync
                        dic="${sessions_dir}/${bssid}.dic${session}"
                        xterm -title "Cracking ${bssid}" $WINDOWCRACK -bg "#000000" -fg "#FFFFFF" -e sh -c "john --session=${sessions_dir}/${bssid} --wordlist=${dic} --stdout --rules=${john_rule} | aircrack-ng -p ${cores} -w - -b ${bssid} -l ${sessions_dir}/${bssid}.cracked ${handshakes_dir}/${bssid}.cap"
                    fi
                fi
            else
                # So, create *.rec and new session starting from john incremental mode
                echo "INC" >"${sessions_dir}/${bssid}.session"
                xterm -title "Cracking ${bssid}" $WINDOWCRACK -bg "#000000" -fg "#FFFFFF" -e sh -c "john --session=${sessions_dir}/${bssid} --incremental:${john_incr} --stdout | aircrack-ng -p ${cores} -w - -b ${bssid} -l ${sessions_dir}/${bssid}.cracked ${handshakes_dir}/${bssid}.cap"
            fi
        fi
        sleep 5
    done
    if is_running "${bssid}"; then
        stop "${bssid}"
    fi
}

function statistics {
    local status tested dic porcent
    for ((i=0; i<${#handshake_files[@]}; i++)); do
        if [ -f "${sessions_dir}/${bssid[$i]}.session" ]; then
            session="$(<${sessions_dir}/${bssid[$i]}.session)"
            if [[ ! $session == "INC" ]]; then
                if [ -f "${sessions_dir}/${bssid[$i]}.rec" ]; then
                    echo "  Processing, wait a few minutes..."
                    status="$(john --status=${sessions_dir}/${bssid[$i]} 2>&1)"
                    tested=$(echo "$status" | cut -d'p' -f1)
                    dic="${sessions_dir}/${bssid[$i]}.dic${session}"
                    total="$(john --wordlist=${dic} --stdout --rules=${john_rule} | wc -l)"
                    porcent=$(( tested / total * 100 ))
                    porcent=$(echo -e "${tested}\t${total}" | awk '{print $1 / $2 * 100}')
                    echo "  --------------------------------------------------------"
                    echo "  BSSID        : $bssid"
                    echo "  John status  : $status"
                    echo "  Total words  : $total"
                    echo "  Tested words : $tested ( ${porcent}% )"
                fi
            fi
        fi
    done
}

# Commandline parameters?
if [ "$#" -gt 0 ]; then
    bssid="$1"
    cores="$2"
    if [[ "$bssid" =~ ^([a-fA-F0-9]{2}:){5}[a-fA-F0-9]{2}$ ]]; then # Valid BSSID?
        while (( cores < 1 || cores > cpus )); do
            echo -ne "${yellow}  Number of CPU cores to use (${transparent}${yellow}1${transparent}-${yellow}${cpus}${transparent}): "
            read -n 1 cores
            echo
        done
        crack_handshake "$bssid" "$cores" &
    fi
else
    load_handshakes
    clear
    top
    select_handshake
fi
